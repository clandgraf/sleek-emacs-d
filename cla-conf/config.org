#+TITLE: Emacs Configuration
#+OPTIONS: toc:nil
#+STARTUP: showall

* Offene Punkte

** Diminish doesn't work

Should be in after-init-hook?

* Before everything else

** Terminal-Specific Stuff

Scrolling did not work out of the box, when using emacs inside tmux,
but the frame receives mouse events, so bind the correct commands
manually.

TODO Scroll Amount seems to be a bit much, can we customize that?

#+BEGIN_SRC emacs-lisp
  (unless (display-graphic-p)
    (defmacro cla/window-frac (frac) `(/ (window-total-height) ,frac))
    (global-set-key (kbd "<mouse-4>") (lambda ()
                                        (interactive)
                                        (scroll-down-command (cla/window-frac 10))))
    (global-set-key (kbd "<mouse-5>") (lambda ()
                                        (interactive)
                                        (scroll-up-command (cla/window-frac 10))))
    (global-set-key (kbd "<prior>") (lambda ()
                                      (interactive)
                                      (scroll-down-command (cla/window-frac 2))))
    (global-set-key (kbd "<next>") (lambda ()
                                     (interactive)
                                     (scroll-up-command (cla/window-frac 2)))))
#+END_SRC

Hack for running emacs in Windows Terminal + SSH to Linux
Box. Ctrl+Space doesn't work for set-mark command so we send a weird
combo.

#+BEGIN_SRC js
{
  "command": {
    "action": "sendInput",
    "input": "\u001b[9~"
  },
  "keys": "ctrl+space"
}
#+END_SRC

Insert the above command in Windows Terminal, and the below binding
will do the trick:

#+BEGIN_SRC emacs-lisp
(global-set-key "\e[9~" 'set-mark-command)
#+END_SRC

# C-<f1> to C-<f4> seem to not work smh, resolve this.

# #+BEGIN_SRC emacs-lisp
# (global-set-key (kbd "\e[1;5r")
#                 (lambda () (interactive) (funcall (global-key-binding (kbd "C-<f3>")))))
# (global-set-key (kbd "\e[1;5S")
#                 (lambda () (interactive) (funcall (global-key-binding (kbd "C-<f4>")))))
# #+END_SRC

Next enable emacs to kill to tmux clipboard,
TODO this ideally should have a check, wether
     this is running in tmux context i guess.

#+BEGIN_SRC emacs-lisp
(defun cla/kill-to-tmux (s)
  (let ((tmux (executable-find "tmux")))
    (if tmux
      (call-process tmux nil nil nil "set-buffer" "-w" s))))

(defun cla/gui-select-text (s)
  (cla/kill-to-tmux s)
  (gui-select-text s))

(setq interprogram-cut-function 'cla/gui-select-text)
#+END_SRC

** Clean UI

Initial Frame size is a bit small for modern screens

#+BEGIN_SRC emacs-lisp
  (setq default-frame-alist
    '((width . 120)
      (height . 50)))
#+END_SRC

Remove all those noobish frame decorations. First two are only
available when running on a graphical display.

#+BEGIN_SRC emacs-lisp
  (ignore-errors
    (tool-bar-mode -1)
    (scroll-bar-mode -1))
  (menu-bar-mode 0)
  (setq inhibit-startup-screen t)
  (global-hl-line-mode 1)
  (xterm-mouse-mode)
#+END_SRC

On TTYs we want a nice vertical border:

#+BEGIN_SRC emacs-lisp
(let ((display-table (or standard-display-table (make-display-table))))
  (set-display-table-slot display-table 'truncation (make-glyph-code ?→))
  (set-display-table-slot display-table 'vertical-border (make-glyph-code ?│))
  (set-display-table-slot display-table 'wrap (make-glyph-code ?↲))
  (setq standard-display-table display-table))
#+END_SRC

** Theme Setup I

#+BEGIN_SRC emacs-lisp
  (defconst cla/the-theme-pkg
    'dracula-theme)
  (defconst cla/the-theme
    'dracula)
#+END_SRC

... let's load up our theme if it exists. Otherwise
we would have to wait for package initialization to
complete while staring at a white window -.-

#+BEGIN_SRC emacs-lisp
  (ignore-errors
    (require 'package)
    (package-initialize)
    (load-theme cla/the-theme))
#+END_SRC

However if we don't have it installed yet, we try a
second time, after package initialization.

** Font Setup

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil
                      :family "SauceCodePro NF"
                      :height 110)
#+END_SRC

* Setup package.el

#+BEGIN_SRC emacs-lisp
  (add-to-list 'package-archives
    '("melpa" . "http://melpa.org/packages/") t)
  (package-refresh-contents)

  (defun cla/install-from-elpa (package)
    (unless (package-installed-p package)
      (package-install package)))
#+END_SRC

* General setup

** Daemon Setup

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :config
  (when (daemonp)
    (exec-path-from-shell-initialize)))
#+END_SRC

** Theme Setup II

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p cla/the-theme-pkg)
    (package-install cla/the-theme-pkg)
    (load-theme cla/the-theme))
#+END_SRC

** Sane Code Formatting

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil) ; never insert tabs
  (setq-default tab-width 4)          ; always indent 4 spaces
  (setq-default c-basic-offset 4)     ; c-mode indent 4 spaces
  (add-hook 'before-save-hook         ; on save remove trailing whitespace
            'delete-trailing-whitespace)
  (set-language-environment "UTF-8")
  (setq-default buffer-file-coding-system 'utf-8-unix)
#+END_SRC

** Visual Bell

#+BEGIN_SRC emacs-lisp
  (setq visible-bell nil
        ring-bell-function 'flash-mode-line)
  (defun flash-mode-line ()
    (invert-face 'mode-line)
    (run-with-timer 0.1 nil #'invert-face 'mode-line))
#+END_SRC

** Clean Directories

Disable emacs to auto-create files when editing

#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil) ; stop creating backup~ files
  (setq auto-save-default nil) ; stop creating #autosave# files
#+END_SRC

** Keychords

windmove is bound to meta, so we can move between adjacent
windows using Alt+Arrow Keys, instead of C-x o. Note that this
collides with default org-mode keys, so first unbind those.

#+BEGIN_SRC emacs-lisp
  (define-key org-mode-map (kbd "<M-up>") nil)
  (define-key org-mode-map (kbd "<M-down>") nil)
  (define-key org-mode-map (kbd "<M-left>") nil)
  (define-key org-mode-map (kbd "<M-right>") nil)
#+END_SRC

tmux-windmove provides replacements for windmove-* functions.
When there is no window in the direction we're moving this will
use tmux select-pane to select the next pane in that direction.

#+BEGIN_SRC emacs-lisp
  (require 'tmux-windmove)
  (tmux/windmove-meta-binding)
#+END_SRC

In order to really work the corresponding part is found in dotfiles:
This contains tmux-configuration to redirect M-<arrow> events to
emacs, if the current pane is running in emacs.

The other key bindings resize the current window using
the arrow keys and Shift+Alt. Useful if you need to see more.

#+BEGIN_SRC
  (global-set-key (kbd "S-M-<up>") 'enlarge-window)
  (global-set-key (kbd "S-M-<down>") 'shrink-window)
  (global-set-key (kbd "S-M-<left>") 'shrink-window-horizontally)
  (global-set-key (kbd "S-M-<right>") 'enlarge-window-horizontally)
#+END_SRC

cla/switch-to-other-buffer is useful when editing two files
in one buffer, for example source/header file.

#+BEGIN_SRC emacs-lisp
  (defun cla/switch-to-other-buffer ()
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer))))

  (global-set-key (kbd "C-<tab>") 'cla/switch-to-other-buffer)
#+END_SRC

This makes home/C-a navigate back to indentation or if
already at indentation col 0, which is more in line with modern
editors.

#+BEGIN_SRC emacs-lisp
  (defun cla/back-to-indentation-or-beginning ()
    (interactive)
    (if (= (point) (progn (back-to-indentation) (point)))
        (beginning-of-line)))

  (global-set-key (kbd "C-a") 'cla/back-to-indentation-or-beginning)
  (global-set-key (kbd "<home>") 'cla/back-to-indentation-or-beginning)
#+END_SRC

*** Error Navigation

next-error/previous-error allow navigating matches e.g. generated from
grepping. These bindings are comfortably reached with the right hand
when using an ansi layout:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-<prior>") 'previous-error)
(global-set-key (kbd "C-<next>") 'next-error)
#+END_SRC

Note: the escape code of "M-[" is the prefix of many Meta-Escape
Codes, e.g. "M-ArrowKeys" and xterm mouse mode.
Disabling this, so we can use all these inputs on terminal.
TODO how can we en-/disable these based on frame?
Global minor mode that is toggled when we switch frames?

** Search

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-<f3>") 'rg-dwim-project-dir)
  (global-set-key (kbd "C-S-<f3>") 'rg-project)
#+END_SRC

** Dired

This enables the 'a' key in dired, which can be used to open the
file or directory at point in the same buffer.

#+BEGIN_SRC emacs-lisp
(put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

** Project.el

#+BEGIN_SRC emacs-lisp
  (setq project-switch-commands '((project-find-file "Find file" "f")
                                  (project-find-dir "Find dir" "d")
                                  (project-dired "Dired" "D")
                                  (consult-ripgrep "ripgrep" "g")
                                  (magit-project-status "Magit" "m")))
#+END_SRC

* Packages

Let's ensure diminish is installed so we can use it later on.

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t)
#+END_SRC

** Tree Sitter

#+BEGIN_SRC emacs-lisp
  (use-package treesit-auto
    :ensure t
    :config
    (global-treesit-auto-mode))
#+END_SRC

** Random Stuff

Stuff that doesn't need much setup

#+BEGIN_SRC emacs-lisp
  (use-package cedm)
  (use-package htmlize
    :ensure t)
  (use-package rg
    :ensure t)
  (use-package markdown-mode
    :ensure t
    :bind (:map markdown-mode-map
                ("C-c i c" . cedm-md-insert-change-request)
                ("C-c i p" . cedm-md-insert-person)))
#+END_SRC

** Magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t)
#+END_SRC

Function to open magit-status in the selected window. Use in
combination with emacsclient -c to open magit-status from shell.

#+BEGIN_SRC emacs-lisp
  (defun cla/magit-status-same-window ()
    (let ((magit-display-buffer-function (lambda (buffer)
                                           (display-buffer buffer '(display-buffer-same-window)))))
      (magit-status)))
#+END_SRC

** Global Utilies

*** Diff HL Mode

Highlight modified lines of code in files under version control

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :ensure t
    :defer 2
    :config
    (global-diff-hl-mode)
    (diff-hl-margin-mode))
#+END_SRC

*** Smart Parens

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :diminish smartparens-mode
    :config (progn
              (require 'smartparens-config)
              (smartparens-global-mode)
              (show-smartparens-global-mode)
              (global-set-key (kbd "C-.") 'sp-select-next-thing)))
#+END_SRC

*** Completion

#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :init
    (savehist-mode))

  (use-package vertico
    :ensure t
    :init
    (vertico-mode))

  (use-package vertico-directory
    :after vertico
    :ensure nil
    :bind (:map vertico-map
                ("RET" . vertico-directory-enter)
                ("DEL" . vertico-directory-delete-char)
                ("M-DEL" . vertico-directory-delete-word)))

  (use-package marginalia
    :ensure t
    :init
    (marginalia-mode))

  (use-package corfu
    :ensure t
    :custom
    (corfu-auto t)
    (corfu-auto-delay 0.2)
    (corfu-auto-prefix 2)
    :init
    (global-corfu-mode))

  (use-package corfu-terminal
    :ensure t
    :custom
    (setq corfu-terminal-disable-on-gui t)
    (corfu-terminal-mode +1))

  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))

  ; Try also consult.el
  (use-package consult
    :ensure t
    :bind (("C-x b" . consult-buffer)
           ("C-x p b" . consult-project-buffer)
           ("M-s g" . consult-ripgrep)))
#+END_SRC

*** IDE-like things, eglot, apheleia, etc

#+BEGIN_SRC emacs-lisp
  (add-hook 'python-ts-mode-hook 'eglot-ensure)

  (use-package dap-mode
    :ensure t
    :config
    (require 'dap-python)
    (setq dap-python-debugger 'debugpy))
#+END_SRC

This does autoformatting automatically on save using external tools

#+BEGIN_SRC emacs-lisp
  (use-package apheleia
    :ensure t
    (apheleia-global-mode +1))
#+END_SRC


*** Smart Mode Line

# #+BEGIN_SRC emacs-lisp
#   (use-package smart-mode-line
#     :ensure t
#     :config
#     (setq sml/theme 'dark)
#     (sml/setup))
# #+END_SRC

*** Doom Mode Line

#+BEGIN_SRC emacs-lisp
  (use-package nerd-icons
    :ensure t)

  (use-package doom-modeline
    :ensure t
    :init
    (doom-modeline-mode 1)
    (setq doom-modeline-buffer-file-name-style 'file-name-with-project))
#+END_SRC

* Web Development

Some minor major-modes (lol) for common formats

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t)
  (use-package mustache-mode
    :ensure t)
#+END_SRC

I think for Javascript/JSX based types I should replace this RJSX.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :mode
    (("\\.tsx\\'" . web-mode)
     ("\\.ts\\'" . web-mode)
     ("\\.json\\'" . web-mode)
     ("\\.html\\'" . web-mode)
     ("\\.css\\'" . web-mode)))
#+END_SRC

Customize indentation

#+BEGIN_SRC emacs-lisp
  (setq sgml-basic-offset 4)
#+END_SRC
